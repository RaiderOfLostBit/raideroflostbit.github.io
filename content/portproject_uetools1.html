<div class="content-section">
    <div class="container-lg">
        <div class="row justify-content-center">
            <div class="col-auto">
                <h2>Unreal Engine 4 - Engine Tools</h2>
            </div>
        </div>
    </div>
</div>
<div class="content-text">
    <div class="container-lg">
        <div class="row justify-content-center">
            <div class="col-11 col-md-9 col-lg-7">
                <div class="clearfix">
                    <p>
                        Based on an idea of a new RTS game by two friends and me, I needed to implement a custom toolset
                        for the Unreal Engine Editor that would allow us to more easily create large game worlds from close-up views
                        to large top-down vistas. The tools were developed as editor plugins to keep them encapsulated and independent of projects.
                    </p>
                    <div class="content-text-section-small">
                        <h5>RVT Painting</h5>
                    </div>
                    <p>
                        RVT Painting is a custom editor mode for texturing landscapes that offers a more modular texturing and painting approach
                        than the built-in tools.
                    </p>
                    <div class="col-12 mt-4 mb-4 position-relative" style="height: 0; padding-bottom: 42.86%;">
                        <a href="assets/img/rvtpainting-title.jpg" data-lightbox="rvtpainting-titel">
                            <img class="img-fluid position-absolute" src="assets/img/rvtpainting-title-small.jpg" height="320" width="746" alt="RVT Painting Title Image">
                        </a>
                    </div>
                    <p>
                        Normally in Unreal, you have to create a complex landscape material with all the layers you need already defined,
                        which can then be painted onto the landscape. If you have a limited team size, it can be difficult to mantain this material.
                    </p>
                    <p>
                        I've always liked the approach that Cryengine takes, where you can create paint layers dynamically as needed.
                        With that in mind, the custom approach makes use of Unreal's Runtime Virtual Texturing System,
                        which is basically a material caching method that reduces render times but increases vram consumption.
                        The ability to render meshes with their materials into this cache and then project them onto a landscape is
                        used to create the layer-based texturing system.
                    </p>
                    <p>
                        In the custom system, each layer has its own RGB weightmap, so three different ground types can be painted per layer.
                        Layers can be created or removed dynamically.
                        Each layer uses an assignable Material Instance that defines the ground types, and a sort index.
                        By changing the sort index, the order of the layers can be adjusted.
                    </p>
                    <p>
                        The Material Instance uses Unreal's Material Layer system to specify each ground type as well as its blending.
                        Several presets for ground and blend types are included, making it easier for artists to use them.
                    </p>
                    <p>
                        The main components of the systems are:
                    </p>
                    <ul>
                        <li>Dynamic creation or removal of painting layers</li>
                        <li>Dynamic sorting of painting layers as well as locking layers and switching visibility</li>
                        <li>Easy swapping of the used Material Instance for a layer, changing its ground types and blending</li>
                        <li>Custom controls for painting, taking into account industry shortcuts</li>
                        <li>Each ground type can have its own physical material as well as its own grass type</li>
                    </ul>
                    <p>
                        Caveats
                    </p>
                    <ul>
                        <li>High vram consumption as two Runtime Virtual Textures are required for now (can be reduced by
                            creating Virtual Textures of high mip levels in the final production phase)</li>
                        <li>Rendering issues while painting (4.27)</li>
                    </ul>
                    <p>The Runtime Virtual Texture is further used for performant Landscape decals, paths and roads.</p>
                    <iframe class="embedded-video" src="https://www.youtube.com/embed/eRwxG1Te6Ws"></iframe>
                    <div class="content-text-section-small">
                        <h5>Instance Scattering</h5>
                    </div>
                    <p>
                        Based on the idea of the
                        <a href="https://www.unrealengine.com/marketplace/en-US/product/simple-scatter" target="_blank">Simple Scatter</a>
                        plugin by ArmyOfOneGames, I implemented a toolset to scatter mesh instances across defined level areas.
                        Currently, it is used to procedurally create foliage or  water surfaces.
                    </p>
                    <div class="col-12 mt-4 mb-4 position-relative" style="height: 0; padding-bottom: 42.86%;">
                        <a href="assets/img/instscatter-title.jpg" data-lightbox="instscatter-titel">
                            <img class="img-fluid position-absolute" src="assets/img/instscatter-title-small.jpg" height="320" width="746" alt="Instance Scatter Title Image">
                        </a>
                    </div>
                    <p>
                        To scatter foliage, you must first define a Foliage Type Asset.
                        This asset is used by the build-in tools but has been extended to include custom scatter parameters.
                        A Foliage Type defines the mesh used, its offset, rotation, collision, ground adjustment and a range of other parameters.
                        The foliage type is then assigned to a Scatter Collection Asset, where you specify the  type's spawn probability
                        and its distribution chance within a defined area gradient.
                    </p>
                    <p>
                        The Scatter Collection is assigned to a placed Scatter Actor within a level.
                        This actor is a manager that creates a grid of possible instance positions and controls the scattering process itself.
                    </p>
                    <p>
                        Created positions are then filtered or additionally generated by so-called Scatter Modifiers,
                        which can be assigned to a scatter actor. Currently there are three types of modifiers:
                    </p>
                    <ul>
                        <li>Spline: The modifier filters positions based on an area within or around a spline component</li>
                        <li>Stamp: Valid positions are controlled by a texture mask projected onto a world surface</li>
                        <li>Line generator: Returns positions along a spline component with adjustable spacing and optional
                            additional radial spread around these positions</li>
                    </ul>
                    <p>
                        For water surfaces, the same modifiers are used, but with a simpler scattering method that creates a grid of planes
                        within the modifier ranges.
                    </p>
                    <iframe class="embedded-video" src="https://www.youtube.com/embed/h8gIzLltuog"></iframe>
                    <div class="content-text-section-small">
                        <h5>Blueprint Brush Collection</h5>
                    </div>
                    <p>
                        A feature of Unreal Engines Landscape Layer System are Blueprint Brushes. They are used to
                        procedurally generate Height- and Weightmaps of landscapes.
                    </p>
                    <div class="col-12 mt-4 mb-4 position-relative" style="height: 0; padding-bottom: 42.86%;">
                        <a href="assets/img/bbc-title.jpg" data-lightbox="bbc-titel">
                            <img class="img-fluid position-absolute" src="assets/img/bbc-title-small.jpg" height="320" width="746" alt="Blueprint Brush Collection Title Image">
                        </a>
                    </div>
                    <p>
                        The Unreal Engine's Landmass plugin contains a number of useful Blueprint Brushes, but they are not yet polished and therefore difficult to use.
                        The main purpose of my Blueprint Brush Collection plugin is to polish up these brushes, fix minor issues
                        and make them easy to use. Weightmap influences are currently ignored as we don't need them in our project.
                    </p>
                    <p>
                        I liked the idea of the Total War Shogun Map Editor, where you can project heightmap textures anywhere on
                        the landscape to create mountains and interesting terrain.
                        I implemented the same approach as a custom blueprint brush. Together with our Landscape Auto-Material,
                        this allows us to quickly create believable, natural landscapes.
                    </p>
                    <iframe class="embedded-video" src="https://www.youtube.com/embed/0Dv8g4FwzUM"></iframe>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="content-end"></div>